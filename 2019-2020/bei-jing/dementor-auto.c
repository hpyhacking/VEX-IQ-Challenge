#pragma config(Sensor, port7,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port8,  touchLED,       sensorVexIQ_LED)
#pragma config(Motor,  motor1,          rightArmMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor2,          leftArmMotor,  tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor3,          hookMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          caterpillarMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          rightWheelMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          leftWheelMotor, tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 1   UpDown_LeftArm(nDegree,nSpeed,nGoTime);
// 2   UpDown_RightArm(nDegree,nSpeed,nGoTime);
// 3   UpDown_Gou(nDegree,nSpeed,nGoTime);
// 4   Go_Forward_Distance(nDistance, nSpeed,nMaxTime);
// 5   Go_Forward_Time(nSpeed,nGoTime,nFactor);
// 6   Gyro_Rotation(nDegree,nSpeed,nMaxTime);

//	1nAct,2nSpeed,3nDegree,4nDistance,5nGoTime,6nMaxtime,7nFactor;

typedef {
	string action;
	int speed;
	int degree;
	int destance;
	int goTime;
	int maxTime;
	int factor;
}

//	1nAct,2nSpeed,3nDegree,4nDistance,5nGoTime,6nMaxtime,nFactor;
int Act[75][7] = {

	//*************************************************************************
	{6, -20, 48, 0, 0, 5000, 0},   // 1   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 1100, 0, 100},   // 2   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{6, 20, 90, 0, 0, 5000, 0},	// 3   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 30, 0, 0, 600, 0, 100},	// 4   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 100, 320, 0, 1000, 0, 0},  // 5   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	{5, 50, 0, 0, 850, 0, 100},	// 6   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{6, -20, 27, 0, 0, 5000, 0},   // 7   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 1000, 0, 100},   // 8   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 30, 150, 0, 700, 0, 0},	// 9   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	{5, -100, 0, 0, 1300, 0, 100}, // 10   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{5, -50, 0, 0, 500, 0, 100},   // 11  Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 50, 0, 0, 1000, 0, 0},	 // 12   UpDown_Arm(nSpeed,nDegree,nGoTime);5

	//*********** 20 OK

	{6, 20, 48, 0, 0, 5000, 0},	// 13   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 1100, 0, 100},   // 14   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{6, -20, 90, 0, 0, 5000, 0},   // 15   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 30, 0, 0, 600, 0, 100},	// 16   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 100, 320, 0, 1000, 0, 0},  // 17   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	{5, 50, 0, 0, 850, 0, 100},	// 18   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{6, 20, 27, 0, 0, 5000, 0},	// 19   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 1000, 0, 100},   // 20   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 30, 150, 0, 700, 0, 0},	// 21   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	{5, -100, 0, 0, 1300, 0, 100}, // 22   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{5, -50, 0, 0, 500, 0, 100},   // 23  Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 50, 0, 0, 1000, 0, 0},	 // 24   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	//*********** 40 OK

	{6, 20, 42, 0, 0, 5000, 0},   // 25   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 1600, 0, 100},  // 26   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 100, 320, 0, 1000, 0, 0}, // 27   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	{5, -50, 0, 0, 1600, 0, 100}, // 28   Go_Forward_Time(nSpeed,nGoTime,nFactor);4

	{6, 20, 78, 0, 0, 5000, 0},  // 29   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 500, 0, 100},  // 30   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{6, -20, 10, 0, 0, 5000, 0}, // 30   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{5, 50, 0, 0, 440, 0, 100},  // 31   Go_Forward_Time(nSpeed,nGoTime,nFactor);4

	{6, -20, 11, 0, 0, 5000, 0}, // 32   Gyro_Rotation(nDegree,nSpeed,nMaxTime);3//20du
	{3, 30, 20, 0, 1000, 0, 0},  // 33   UpDown_Arm(nSpeed,nDegree,nGoTime);5
	{5, -50, 0, 0, 500, 0, 100}, // 34   Go_Forward_Time(nSpeed,nGoTime,nFactor);4
	{3, 100, 0, 0, 1000, 0, 0},  // 35   UpDown_Arm(nSpeed,nDegree,nGoTime);5

	//********60-ok***********************************

};

//	nAct,nSpeed,nDegree,nDistance,nGoTime,nMaxtime,nFactor;
void Init_Car();

void UpDown_Gou(int nSpeed, int nDegree, int nDelayTime);

void UpDown_Claw(int nSpeed, int nDegree, int nDelayTime);

void UpDown_Arm(int nSpeed, int nDegree, int nDelayTime);

void Gyro_Rotation(int nSpeed, int nDegree, int nMaxTime);

void Go_Forward_Distance(int nSpeed, int nDistance, int nMaxTime);

void Go_Forward_Time(int nSpeed, int nDelay, int nFactor);

//main *****************************************************************
task main()
{
	int i;
	int nAct; //
	int nSpeed;
	int nDegree;
	int nDistance;
	int nGoTime;
	int nMaxtime;
	int nFactor;
	Init_Car();

	//	 UpDown_Arm(100,400,1500);

	setTouchLEDColor(TouchLED1, colorRed);		   // set touch LED color as Red
	waitUntil((getTouchLEDValue(TouchLED1) == 1)); // wait touch
	setTouchLEDColor(TouchLED1, colorGreen);	   // when touch LED, its color change to Green
	for (i = 0; i < 12; i++)
	{
		nAct = Act[i][0];
		nSpeed = Act[i][1];
		nDegree = Act[i][2];
		nDistance = Act[i][3];
		nGoTime = Act[i][4];
		nMaxtime = Act[i][5];
		nFactor = Act[i][6];

		//   while(i==12);//******************************************

		switch (nAct)
		{
		case 1:
			UpDown_Gou(nSpeed, nDegree, nGoTime);
			break;
		case 2:
			UpDown_Claw(nSpeed, nDegree, nGoTime);
			break;
		case 3:
			UpDown_Arm(nSpeed, nDegree, nGoTime);
			break;
		case 4:
			Go_Forward_Distance(nSpeed, nDistance, nMaxTime);
			break;
		case 5:
			Go_Forward_Time(nSpeed, nGoTime, nFactor);
			break;
		case 6:
			Gyro_Rotation(nSpeed, nDegree, nMaxTime);
			break;
		}
		delay(50);
	}

	setTouchLEDColor(TouchLED1, colorRed);		   // set touch LED color as Red
	waitUntil((getTouchLEDValue(TouchLED1) == 1)); // wait touch
	setTouchLEDColor(TouchLED1, colorGreen);	   // when touch LED, its color change to Green	 for(i=12;i<24;i++)

	for (i = 12; i < 24; i++)
	{
		nAct = Act[i][0]; //
		nSpeed = Act[i][1];
		nDegree = Act[i][2];
		nDistance = Act[i][3];
		nGoTime = Act[i][4];
		nMaxtime = Act[i][5];
		nFactor = Act[i][6];

		//while(i==24);//******************************************

		switch (nAct)
		{
		case 1:
			UpDown_Gou(nSpeed, nDegree, nGoTime);
			break;
		case 2:
			UpDown_Claw(nSpeed, nDegree, nGoTime);
			break;
		case 3:
			UpDown_Arm(nSpeed, nDegree, nGoTime);
			break;
		case 4:
			Go_Forward_Distance(nSpeed, nDistance, nMaxTime);
			break;
		case 5:
			Go_Forward_Time(nSpeed, nGoTime, nFactor);
			break;
		case 6:
			Gyro_Rotation(nSpeed, nDegree, nMaxTime);
			break;
		}
		delay(50);
	}

	setTouchLEDColor(TouchLED1, colorRed);		   // set touch LED color as Red
	waitUntil((getTouchLEDValue(TouchLED1) == 1)); // wait touch
	setTouchLEDColor(TouchLED1, colorGreen);	   // when touch LED, its color change to Green
	for (i = 24; i < 36; i++)
	//for(i=0;i<35;i++)
	{
		nAct = Act[i][0];
		nSpeed = Act[i][1];
		nDegree = Act[i][2];
		nDistance = Act[i][3];
		nGoTime = Act[i][4];
		nMaxtime = Act[i][5];
		nFactor = Act[i][6];

		// while(i==35);//******************************************

		switch (nAct)
		{
		case 1:
			UpDown_Gou(nSpeed, nDegree, nGoTime);
			break;
		case 2:
			UpDown_Claw(nSpeed, nDegree, nGoTime);
			break;
		case 3:
			UpDown_Arm(nSpeed, nDegree, nGoTime);
			break;
		case 4:
			Go_Forward_Distance(nSpeed, nDistance, nMaxTime);
			break;
		case 5:
			Go_Forward_Time(nSpeed, nGoTime, nFactor);
			break;
		case 6:
			Gyro_Rotation(nSpeed, nDegree, nMaxTime);
			break;
		}
		delay(50);
	}
	/*
setTouchLEDColor(TouchLED1, colorRed);     // set touch LED color as Red
waitUntil((getTouchLEDValue(TouchLED1)==1)); // wait touch
setTouchLEDColor(TouchLED1, colorGreen);   // when touch LED, its color change to Green

	 for(i=35;i<58;i++)
	 {
	     nAct=Act[i][0];
       nSpeed=Act[i][1];
	     nDegree=Act[i][2];
	     nDistance=Act[i][3];
	     nGoTime=Act[i][4];
	     nMaxtime=Act[i][5];
	     nFactor=Act[i][6];



	     //while(i==43);//******************************************


	     switch(nAct)
	     {
	         case 1:
	             UpDown_Gou(nSpeed,nDegree,nGoTime);
	         break;
	         case 2:
	             UpDown_Claw(nSpeed,nDegree,nGoTime);
	         break;
	         case 3:
	             UpDown_Arm(nSpeed,nDegree,nGoTime);
	         break;
	         case 4:
	             Go_Forward_Distance(nSpeed,nDistance, nMaxTime);
	         break;
	         case 5:
	             Go_Forward_Time(nSpeed,nGoTime,nFactor);
	         break;
	         case 6:
	              Gyro_Rotation(nSpeed,nDegree,nMaxTime);
	         break;
	     }
	  delay(50);

	  }*/
}

void Init_Car()
{
	//	setMotorEncoderUnits(encoderDegrees);
	resetMotorEncoder(rightarmMotor);
	resetMotorEncoder(ClawMotor);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftarmMotor);
	resetMotorEncoder(gouMotor);
	resetMotorEncoder(LeftMotor);
}

void UpDown_Gou(int nSpeed, int nDegree, int nDelayTime)
{
	setMotorTarget(gouMotor, nDegree, nSpeed);
	delay(nDelayTime);
	setMotorTarget(gouMotor, nDegree, 0);
}

void UpDown_Claw(int nSpeed, int nDegree, int nDelayTime)
{
	setMotorTarget(ClawMotor, nDegree, nSpeed);
	delay(nDelayTime);
	setMotorTarget(ClawMotor, nDegree, 0);
}

void UpDown_Arm(int nSpeed, int nDegree, int nDelayTime)
{
	setMotorTarget(leftarmMotor, nDegree, nSpeed);
	setMotorTarget(rightarmMotor, nDegree, nSpeed);
	delay(nDelayTime);
	setMotorTarget(leftarmMotor, nDegree, 0);
	setMotorTarget(rightarmMotor, nDegree, 0);
}

void Gyro_Rotation(int nSpeed, int nDegree, int nMaxTime)
{
	int real_degree = 0;
	clearTimer(T1); // Resets timer T1 to start counting at 0
	resetGyro(Gyro);
	real_degree = abs(getGyroHeading(Gyro));
	setMotorSpeed(LeftMotor, nSpeed);
	setMotorSpeed(rightMotor, -nSpeed);
	while (real_degree < nDegree)
	{
		real_degree = abs(getGyroHeading(Gyro));
		displayTextLine(2, "%d", real_degree);
		if (time1[T1] > nMaxTime)
		{
			playNote(noteCSharp, octave2, 200);
			break;
		}
	}
	setMotorSpeed(LeftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

/*

*/
void Go_Forward_Distance(int nSpeed, int nDistance, int nMaxTime)
{
	int nTarget_Degree;
	int nDegree_Temp;
	clearTimer(T1); // Resets timer T1 to start counting at 0
	nTarget_Degree = (float)nDistance / 200 * 360;
	resetMotorEncoder(LeftMotor);
	//setMotorTarget(LeftMotor,nTarget_Degree,nSpeed);
	//setMotorTarget(rightMotor,nTarget_Degree,nSpeed);

	setMotorSpeed(LeftMotor, nSpeed);
	setMotorSpeed(rightMotor, nSpeed);
	nDegree_Temp = getServoEncoder(LeftMotor);

	while (nDegree_Temp < nTarget_Degree) //while the Sonar Sensor read data greater than '20':
	{
		nDegree_Temp = abs(getServoEncoder(LeftMotor));
		displayTextLine(2, "%d", nDegree_Temp);
		if (time1[T1] > nMaxTime)
		{
			playNote(noteCSharp, octave2, 200);
			break;
		}
	}
	setMotorSpeed(LeftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

/*

*/
void Go_Forward_Time(int nSpeed, int nDelay, int nFactor)
{
	int nSpeedTemp;
	int nDelayTemp;
	int i;
	float fFactor;
	int nLeftSpeed, nRightSpeed;
	fFactor = (float)nFactor / 100;
	nSpeedTemp = nSpeed / 5;
	nDelayTemp = nDelay / 50;
	for (i = 1; i <= 5; i++)
	{
		nLeftSpeed = nSpeedTemp * i;
		nRightSpeed = nLeftSpeed * fFactor;
		setMotorSpeed(LeftMotor, nLeftSpeed);
		setMotorSpeed(rightMotor, nRightSpeed);
		delay(5);
	}
	delay(nDelay - 50);
	for (i = 5; i >= 1; i--)
	{
		nLeftSpeed = nSpeedTemp * i;
		nRightSpeed = nLeftSpeed * fFactor;
		setMotorSpeed(LeftMotor, nLeftSpeed);
		setMotorSpeed(rightMotor, nRightSpeed);
		delay(5);
	}
	setMotorSpeed(LeftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	delay(5);
}
